# 对象

## 有哪些创建对象的方式

[夯实基本功之：Java程序员找对象攻虐！](https://mp.weixin.qq.com/s/aZg9SZT3DWkCkEsjlUjTtQ)

+ new一个对象

  通过`new`的方式，我们可以调用类的**无参**或者**有参**构造方法来实例化出一个对象

+ 反射出一个对象

  + 有了`Class`对象之后，接下来就可以调用其`newInstance()`方法来创建一个对象。当然，这种方式的局限性也有目共睹，因为使用的是类的**无参**构造方法来创建的对象

  + 在我们拿到了类的`Class`对象后，就可以通过`getDeclaredConstructors()`函数来获取到类的所有构造函数列表，这样我们就可以调用对应的构造函数来创建对象了

+ Unsafe黑魔法

  Unsafe类中有一个allocateInstance()方法，通过其就可以创建一个对象。为此我们只需要获取到一个Unsafe类的实例对象，我们自然就可以调用allocateInstance()来创建对象了

+ 对象的隐式创建场景

  + Class类实例隐式创建

    JVM虚拟机在加载一个类的时候，也都会创建一个类对应的Class实例对象，很明显这一过程是JVM偷偷地背着我们干的

  + 字符串隐式对象创建

    定义一个String类型的字面变量时，就可能会引起一个新的String对象的创建

    还常见的比如String的+号连接符也会隐式地导致新String对象的创建

  + 自动装箱机制

  + 函数可变参数

    背地里可能会隐式地产生一个对应的数组对象进行计算

## new 的原理

1. 首先，当我们`new`一个对象时，比如`Sheep sheep = new Sheep()`，`JVM`首先就回去检查`Sheep`这个符号引用所代表的类是否已经被加载过，如果没有就要执行对应类的加载过程；
2. 声明类型引用很简单，比如`Sheep sheep = new Sheep()`就会声明一个`Sheep`类型的引用`sheep`；
3. 第一步类加载完成以后，对象所需的内存大小其实就已经确定下来了，接下来`JVM`就会在堆上为对象分配内存；
4. 所谓的属性“`0`”值初始化非常好理解，即为实例化对象的各个属性赋上默认初始化“0”值，比如int的初始化0值就是0，而一个对象的初始化0值就是null；
5. 接下来JVM会进行对象头的设置，这里面就主要包括对象的运行时数据（比如Hash码、分代年龄、锁状态标志、锁指针、偏向线程ID、偏向时间戳等）以及类型指针（JVM通过该类型指针来确定该对象是哪个类的实例）；
6. 属性的显示初始化也好理解，比如定义一个类的时候，针对某个属性字段手动的赋值，如：`private String name = "codesheep";` 就在这时候给初始化上；
7. 最后是调用类的构造方法来进行进行构造方法内描述的初始化动作

## 创建对象时，类的初始化顺序

java

https://www.zhihu.com/question/49196023/answer/114734606

### kotlin

```
主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中
在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起
请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块
在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前
```

## Activity对象是如何被创建的

## 对象存放在哪里 引用存放在哪里

## 对象的生命周期

[Java对象生命周期](https://zhuanlan.zhihu.com/p/104056490)

+ 创建阶段（Creation）

+ 应用阶段（Using）

  至少被一个强引用持有着

+ 不可视阶段（Invisible）

  即使有强引用持有对象，但是这些强引用对于程序来说是不能访问的（accessible），就会进入这个阶段（非必须经历的阶段）

+ 不可到达阶段（Unreachable）

  该对象不再被任何由gc root的强引用的引用链可达的状态

+ 可收集阶段（Collected）

  当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，对象进入“收集阶段”。如果该对象已经重写了finalize()方法，并且没有被执行过，则执行该方法的操作。否则直接进入终结阶段

+ 终结阶段（Finalized）

  当对象执行完finalize()方法后仍然处于不可达状态时，该对象进入终结阶段。在该阶段，等待垃圾回收器回收该对象空间

+ 释放阶段（Free）

  如果在完成上述所有工作完成后对象仍不可达，则垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，该对象彻底消失

## 对象内存布局

[聊聊java对象内存布局](https://zhuanlan.zhihu.com/p/50984945)

[“对象头(object header)”里知多少](https://juejin.cn/post/6844904113306615822#heading-0)

[图文详解Java对象内存布局](https://zhuanlan.zhihu.com/p/362023210)

+ 对象头(Object Header)

  + Mark Word

    用于存储对象运行时的数据，好比 HashCode、锁状态标志、GC分代年龄等。**这部分在 64 位操作系统下占 8 字节，32 位操作系统下占 4 字节**

  + Class Pointer

    对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。在开启指针压缩的状况下占 4 字节，未开启状况下占 8 字节

  + 数组长度：这部分只有是数组对象才有，若是是非数组对象就没这部分。这部分占 4 字节

+ 实例数据(instance data)

+ 对齐填充(padding)

  Java 对象的大小默认是按照 8 字节对齐，也就是说 Java 对象的大小必须是 8 字节的倍数。若是算到最后不够 8 字节的话，那么就会进行对齐填充

  由于 CPU 进行内存访问时，一次寻址的指针大小是 8 字节，正好也是 L1 缓存行的大小。如果不进行内存对齐，则可能出现跨缓存行的情况，这叫做 缓存行污染

## 对象的大小如何计算

[高端面试必备：一个Java对象占用多大内存](https://www.cnblogs.com/rickiyang/p/14206724.html) 

[一个Java对象到底占用多大内存？](https://juejin.cn/post/6844904022101475342)

## 对象不可变是如何实现的，意义是什么

## String不可变是如何实现的

## String如何被创建

## 浅复制 深度复制

[Java 到底是值传递还是引用传递？](https://www.zhihu.com/question/31203609/answer/50992895)

对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。
对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。**但是原来的对象不会被改变（重要）**

调用方法时发生了什么？**参数传递基本上就是赋值操作**

[一个工作三年的同事，居然还搞不清深拷贝、浅拷贝...](https://mp.weixin.qq.com/s/ypCIMGxyp7AX5cxG5UJ1Hg)

因为深拷贝、浅拷贝的区别在于更改拷贝值是否影响原值，由于String类型不可更改，所以在拷贝时String可被认为是值传递，和基本类型同样

+ 浅拷贝

  值类型的字段会复制一份，而引用类型的字段拷贝的仅仅是引用地址，而该引用地址指向的实际对象空间其实只有一份

+ 深拷贝

  深拷贝相较于上面所示的浅拷贝，除了值类型字段会复制一份，引用类型字段所指向的对象，会在内存中也创建一个副本

  利用反序列化技术，我们也可以从一个对象深拷贝出另一个复制对象，而且这货在解决多层套娃式的深拷贝问题时效果出奇的好

[在Java中为什么实现了Cloneable接口，就能调用Object的clone方法？](https://www.zhihu.com/question/52490586/answer/130786763)

从JVM的角度看，这就是一个标记接口而已。实现了就是打上cloneable标记，没实现就是没这个标记

然后到clone()的基本实现中，JVM会去检测要clone的对象的类有没有被打上这个标记，有就让clone，没有就抛异常。就这么简单

### kotlin

https://stackoverflow.com/questions/47359496/kotlin-data-class-copy-method-not-deep-copying-all-members

```
The copy method of Kotlin is not supposed to be a deep copy at all
it's a shallow copy

There is a way to make a deep copy of an object in Kotlin (and Java): serialize it to memory and then deserialize it back to a new object. This will only work if all the data contained in the object are either primitives or implement the Serializable interface
```

